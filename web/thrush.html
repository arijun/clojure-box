<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Thrush Combinators in Clojure</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2010-09-28 15:26:30 "/>
<meta name="author" content="Shawn Hoover"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="styles.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">Thrush Combinators in Clojure</h1>




<style type="text/css">
  body { width: 90%; max-width: 700px; min-width: 500px;
    font-family: Georgia, Arial;
  }
  code { font-family: monospace, consolas, courier; }
  pre {
    border: 1pt solid #aebdcc;
    background-color: #1c1c1c;
    color: #dcdccc;
    max-width: 600px;
    min-width: 400px;
    margin: 5px 30px 10px 30px;
    font-family: monospace, consolas, courier;
    font-size: 90%;
    overflow:auto;
  }
</style>

<p>
As I read <a href="http://github.com/raganwald/homoiconic/blob/master/2008-10-30/thrush.markdown#readme">Raganwald on Thrushes</a>, I found myself thinking surely some
combinators were built in to Clojure already, and if so which ones? I decided
to try porting the thrushes to Clojure.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Ruby Versions </h2>
<div class="outline-text-2" id="text-1">


<p>
The <code>into</code> thrush lets you change from:
</p>



<pre class="src src-ruby">lambda { |x| x * x }.call((1..100).select(&amp;<span style="color: #dca3a3; font-weight: bold;">:odd?</span>).inject(&amp;<span style="color: #dca3a3; font-weight: bold;">:+</span>))
</pre>



<p>
to:
</p>



<pre class="src src-ruby">(1..100).select(&amp;<span style="color: #dca3a3; font-weight: bold;">:odd?</span>).inject(&amp;<span style="color: #dca3a3; font-weight: bold;">:+</span>).into { |x| x * x }
</pre>



<p>
It reads better because everything is chained instead of the square wrapping
the rest of the chain.
</p>
<p>
But then for some reason relating to scoping local variables he makes the
<code>let</code> thrush:
</p>



<pre class="src src-ruby">let (1..100).select(&amp;<span style="color: #dca3a3; font-weight: bold;">:odd?</span>).inject(&amp;<span style="color: #dca3a3; font-weight: bold;">:+</span>) <span style="color: #f0dfaf; font-weight: bold;">do</span> |x| 
  x * x
<span style="color: #f0dfaf; font-weight: bold;">end</span>
</pre>



<p>
I don't understand why that's different than the chained into block, but he
seems to be saying the let with do/end protects the surrounding scope better.
</p>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Clojure Versions </h2>
<div class="outline-text-2" id="text-2">


<p>
I thought the into thrush would be trivial in Clojure using the thread macro
<code>-&gt;</code>. It turns out the other thread macro <code>-&gt;&gt;</code> is required, and it wasn't quite
as trivial as I thought. Just like in Ruby, if you had a square function
already, you could just chain it on the end, but if you want ad hoc logic, you
have to provide a closure. The semantics of the <code>-&gt;&gt;</code> macro evaluation require
wrapping the closure in extra parens.
</p>



<pre class="src src-clojure"><span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">-&gt;&gt;</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">range</span> 1 101<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">filter</span> odd?<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">reduce</span> +<span style="color: #606060;">)</span> <span style="color: #606060;">(</span>#<span style="color: #606060;">(</span><span style="color: #8cd0d3;">*</span> % %<span style="color: #606060;">)))</span>
<span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">-&gt;&gt;</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">range</span> 1 101<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">filter</span> odd?<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">reduce</span> +<span style="color: #606060;">)</span> <span style="color: #606060;">((</span><span style="color: #8cd0d3;">fn</span> <span style="color: #606060;">[</span>x<span style="color: #606060;">]</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">*</span> x x<span style="color: #606060;">))))</span>

<span style="color: #708070;">;; </span><span style="color: #7f9f7f;">If you don't like the parens doing seemingly nothing, you can
</span><span style="color: #708070;">;; </span><span style="color: #7f9f7f;">throw a name in there.
</span><span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">defn</span> <span style="color: #f0dfaf;">my-into</span> <span style="color: #606060;">[</span>f val<span style="color: #606060;">]</span>
  <span style="color: #606060;">(</span>f val<span style="color: #606060;">))</span>
<span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">-&gt;&gt;</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">range</span> 1 101<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">filter</span> odd?<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">reduce</span> +<span style="color: #606060;">)</span> <span style="color: #606060;">(</span>my-into #<span style="color: #606060;">(</span><span style="color: #8cd0d3;">*</span> % %<span style="color: #606060;">)))</span>

<span style="color: #708070;">;; </span><span style="color: #7f9f7f;">Or use a macro to make it look more like the Ruby version.
</span><span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">defmacro</span> <span style="color: #f0dfaf;">my-into2</span> <span style="color: #606060;">[[</span>x<span style="color: #606060;">]</span> &amp; body+val<span style="color: #606060;">]</span>
  <span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">let</span> <span style="color: #606060;">[</span>val <span style="color: #606060;">(</span><span style="color: #8cd0d3;">last</span> body+val<span style="color: #606060;">)</span>
        body <span style="color: #606060;">(</span><span style="color: #8cd0d3;">butlast</span> body+val<span style="color: #606060;">)]</span>
    `<span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">let</span> <span style="color: #606060;">[</span>~x ~val<span style="color: #606060;">]</span>
       ~@body<span style="color: #606060;">)))</span>

<span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">-&gt;&gt;</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">range</span> 1 101<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">filter</span> odd?<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">reduce</span> +<span style="color: #606060;">)</span> <span style="color: #606060;">(</span>my-into2 <span style="color: #606060;">[</span>x<span style="color: #606060;">]</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">*</span> x x<span style="color: #606060;">)))</span>
</pre>



<p>
The let thrush is, of course, built in to Clojure:
</p>



<pre class="src src-clojure"><span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">let</span> <span style="color: #606060;">[</span>x <span style="color: #606060;">(</span><span style="color: #f0dfaf; font-weight: bold;">-&gt;&gt;</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">range</span> 1 101<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">filter</span> odd?<span style="color: #606060;">)</span> <span style="color: #606060;">(</span><span style="color: #8cd0d3;">reduce</span> +<span style="color: #606060;">))]</span>
  <span style="color: #606060;">(</span><span style="color: #8cd0d3;">*</span> x x<span style="color: #606060;">))</span>
</pre>



<p>
In practice in Clojure I think the overhead of understanding my-into is a
little steep, so I would probably just use let and call it a day. Or maybe
there's a better way in Clojure that I'm not thinking of.
</p>

</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1">And Then </h3>
<div class="outline-text-3" id="text-2.1">


<p>
And then I brought it up in #clojure and got taken to school. Chouser made the
point that <code>-&gt;&gt;</code> is a macro and therefore can't technically be a
combinator. Indeed, it can cause trouble:
</p>



<pre class="example">&lt;chouser&gt; ,(-&gt;&gt; (* i 2) (let [i 10]))
&lt;clojurebot&gt; 20
</pre>



<p>
The <code>-&gt;&gt;</code> macro is not really gathering up the arguments and calling them as
it goes along. It reorders the code into nested calls, thus the binding of i
in the final let form affects the outcome of the multiplication. Oops!
</p>
<p>
Here's how it's implemented as a function:
</p>



<pre class="example">&lt;chouser&gt; (defn thrush [&amp; args] (reduce #(%2 %1) args))
&lt;chouser&gt; (thrush 5 sqr (fn [x] (+ 1 x)) #(Math/sqrt %) int str) ;=&gt;
          "5"
&lt;_fogus_&gt; chouser: Or another way to "visualize" thrush is (defn
          thrush [a &amp; args] ((apply comp (reverse args)) a))
</pre>



<p>
_fogus_'s <code>comp</code> version maps very nicely to how I think of the thrush
combinator, and chouser's <code>reduce</code> version is simply stunning. The way it
steps past the first argument without calling it as a function is a very
clever use of the semantics of <code>reduce</code>. Now, these versions being functions
and not macros, the compiler won't allow the syntactic deception chouser
shoved through <code>-&gt;&gt;</code> above, but that was exactly his point: <code>-&gt;&gt;</code> messes with
syntax, it doesn't just compose function calls. Book authors say to write
macros only when a function won't do, and the errant <code>i</code> above shows how
<i>calling</i> macros requires much care, as well.
</p></div>
</div>
</div>
<div id="postamble">
</div>
</div>
</body>
</html>
